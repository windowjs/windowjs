diff --git a/docs/intro.dox b/docs/intro.dox
index e563b505..4bd4ec5f 100644
--- a/docs/intro.dox
+++ b/docs/intro.dox
@@ -101,14 +101,22 @@ __GLFW_COCOA_MENUBAR__ specifies whether to create a basic menu bar, either from
 a nib or manually, when the first window is created, which is when AppKit is
 initialized.  Set this with @ref glfwInitHint.
 
+@anchor GLFW_WIN32_MESSAGES_IN_FIBER_hint
+__GLFW_WIN32_MESSAGES_IN_FIBER__ specifies whether to use separate fiber for
+processing Windows message, and not the main thread. This allows to unblock
+window move and resize operations, and application can do updates and rendering
+in its main loop. __Warning__ - setting this hint is not safe for environments
+or frameworks where stack inspection is required (for example, moving garbage
+collected languages such as Java or C#).  Set this with @ref glfwInitHint.
 
 @subsubsection init_hints_values Supported and default values
 
-Initialization hint             | Default value | Supported values
-------------------------------- | ------------- | ----------------
-@ref GLFW_JOYSTICK_HAT_BUTTONS  | `GLFW_TRUE`   | `GLFW_TRUE` or `GLFW_FALSE`
-@ref GLFW_COCOA_CHDIR_RESOURCES | `GLFW_TRUE`   | `GLFW_TRUE` or `GLFW_FALSE`
-@ref GLFW_COCOA_MENUBAR         | `GLFW_TRUE`   | `GLFW_TRUE` or `GLFW_FALSE`
+Initialization hint               | Default value | Supported values
+--------------------------------- | ------------- | ----------------
+@ref GLFW_JOYSTICK_HAT_BUTTONS    | `GLFW_TRUE`   | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_COCOA_CHDIR_RESOURCES   | `GLFW_TRUE`   | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_COCOA_MENUBAR           | `GLFW_TRUE`   | `GLFW_TRUE` or `GLFW_FALSE`
+@ref GLFW_WIN32_MESSAGES_IN_FIBER | `GLFW_FALSE`  | `GLFW_TRUE` or `GLFW_FALSE`
 
 
 @subsection intro_init_terminate Terminating GLFW
diff --git a/include/GLFW/glfw3.h b/include/GLFW/glfw3.h
index 9503dd0d..4aece364 100644
--- a/include/GLFW/glfw3.h
+++ b/include/GLFW/glfw3.h
@@ -1124,6 +1124,11 @@ extern "C" {
  *  macOS specific [init hint](@ref GLFW_COCOA_MENUBAR_hint).
  */
 #define GLFW_COCOA_MENUBAR          0x00051002
+/*! @brief Windows specific init hint.
+ *
+ *  Windows specific [init hint](@ref GLFW_WIN32_MESSAGES_IN_FIBER_hint).
+ */
+#define GLFW_WIN32_MESSAGES_IN_FIBER 0x00051003
 /*! @} */
 
 #define GLFW_DONT_CARE              -1
@@ -1235,6 +1240,10 @@ typedef void (* GLFWerrorfun)(int error_code, const char* description);
  *  @param[in] ypos The new y-coordinate, in screen coordinates, of the
  *  upper-left corner of the content area of the window.
  *
+ *  @remark @win32 On Windows moving or resizing of window will block event
+ *  processing. Workaround for this is @ref GLFW_WIN32_MESSAGES_IN_FIBER init
+ *  hint.
+ *
  *  @sa @ref window_pos
  *  @sa @ref glfwSetWindowPosCallback
  *
@@ -1256,6 +1265,10 @@ typedef void (* GLFWwindowposfun)(GLFWwindow* window, int xpos, int ypos);
  *  @param[in] width The new width, in screen coordinates, of the window.
  *  @param[in] height The new height, in screen coordinates, of the window.
  *
+ *  @remark @win32 On Windows moving or resizing of window will block event
+ *  processing. Workaround for this is @ref GLFW_WIN32_MESSAGES_IN_FIBER init
+ *  hint.
+ *
  *  @sa @ref window_size
  *  @sa @ref glfwSetWindowSizeCallback
  *
diff --git a/src/cocoa_init.m b/src/cocoa_init.m
index 209639e2..12889c9c 100644
--- a/src/cocoa_init.m
+++ b/src/cocoa_init.m
@@ -32,6 +32,8 @@
 // Needed for _NSGetProgname
 #include <crt_externs.h>
 
+#include <stdio.h>
+
 // Change to our application bundle's resources directory, if present
 //
 static void changeToResourcesDirectory(void)
@@ -497,6 +499,7 @@ void* _glfwLoadLocalVulkanLoaderNS(void)
 
 int _glfwPlatformInit(void)
 {
+    fprintf(stderr, "-- _glfwPlatformInit 1\n");
     @autoreleasepool {
 
     _glfw.ns.helper = [[GLFWHelper alloc] init];
@@ -559,7 +562,9 @@ int _glfwPlatformInit(void)
     _glfwInitTimerNS();
     _glfwInitJoysticksNS();
 
+    fprintf(stderr, "-- _glfwPlatformInit calling _glfwPollMonitorsNS\n");
     _glfwPollMonitorsNS();
+    fprintf(stderr, "-- _glfwPlatformInit _glfwPollMonitorsNS returned\n");
     return GLFW_TRUE;
 
     } // autoreleasepool
diff --git a/src/cocoa_monitor.m b/src/cocoa_monitor.m
index f64d78d7..544656b2 100644
--- a/src/cocoa_monitor.m
+++ b/src/cocoa_monitor.m
@@ -226,67 +226,91 @@ static void endFadeReservation(CGDisplayFadeReservationToken token)
 //
 static double getFallbackRefreshRate(CGDirectDisplayID displayID)
 {
+    fprintf(stderr, "-- getFallbackRefreshRate 1\n");
     double refreshRate = 60.0;
 
     io_iterator_t it;
     io_service_t service;
+    fprintf(stderr, "-- getFallbackRefreshRate 2\n");
 
     if (IOServiceGetMatchingServices(kIOMainPortDefault,
                                      IOServiceMatching("IOFramebuffer"),
                                      &it) != 0)
     {
+        fprintf(stderr, "-- getFallbackRefreshRate 2 return\n");
         return refreshRate;
     }
+      fprintf(stderr, "-- getFallbackRefreshRate 3 return\n");
 
     while ((service = IOIteratorNext(it)) != 0)
     {
+        fprintf(stderr, "-- getFallbackRefreshRate loop 1\n");
         const CFNumberRef indexRef =
             IORegistryEntryCreateCFProperty(service,
                                             CFSTR("IOFramebufferOpenGLIndex"),
                                             kCFAllocatorDefault,
                                             kNilOptions);
+        fprintf(stderr, "-- getFallbackRefreshRate loop 2\n");
         if (!indexRef)
             continue;
 
+        fprintf(stderr, "-- getFallbackRefreshRate loop 3\n");
         uint32_t index = 0;
         CFNumberGetValue(indexRef, kCFNumberIntType, &index);
         CFRelease(indexRef);
+        fprintf(stderr, "-- getFallbackRefreshRate loop 4\n");
 
         if (CGOpenGLDisplayMaskToDisplayID(1 << index) != displayID)
             continue;
+        fprintf(stderr, "-- getFallbackRefreshRate loop 5\n");
 
         const CFNumberRef clockRef =
             IORegistryEntryCreateCFProperty(service,
                                             CFSTR("IOFBCurrentPixelClock"),
                                             kCFAllocatorDefault,
                                             kNilOptions);
+        fprintf(stderr, "-- getFallbackRefreshRate loop 6\n");
         const CFNumberRef countRef =
             IORegistryEntryCreateCFProperty(service,
                                             CFSTR("IOFBCurrentPixelCount"),
                                             kCFAllocatorDefault,
                                             kNilOptions);
+        fprintf(stderr, "-- getFallbackRefreshRate loop 7\n");
 
         uint32_t clock = 0, count = 0;
 
         if (clockRef)
         {
+            fprintf(stderr, "-- getFallbackRefreshRate loop 8\n");
             CFNumberGetValue(clockRef, kCFNumberIntType, &clock);
+            fprintf(stderr, "-- getFallbackRefreshRate loop 9\n");
             CFRelease(clockRef);
+            fprintf(stderr, "-- getFallbackRefreshRate loop 10\n");
         }
+        fprintf(stderr, "-- getFallbackRefreshRate loop 11\n");
 
         if (countRef)
         {
+            fprintf(stderr, "-- getFallbackRefreshRate loop 12\n");
             CFNumberGetValue(countRef, kCFNumberIntType, &count);
+            fprintf(stderr, "-- getFallbackRefreshRate loop 13\n");
             CFRelease(countRef);
+            fprintf(stderr, "-- getFallbackRefreshRate loop 14\n");
         }
+        fprintf(stderr, "-- getFallbackRefreshRate loop 15\n");
 
-        if (clock > 0 && count > 0)
+        if (clock > 0 && count > 0) {
+            fprintf(stderr, "-- getFallbackRefreshRate loop 16 count is %u\n", count);
             refreshRate = clock / (double) count;
+        }
+        fprintf(stderr, "-- getFallbackRefreshRate loop 17\n");
 
         break;
     }
+    fprintf(stderr, "-- getFallbackRefreshRate loop 18\n");
 
     IOObjectRelease(it);
+    fprintf(stderr, "-- getFallbackRefreshRate loop 19\n");
     return refreshRate;
 }
 
@@ -299,16 +323,23 @@ static double getFallbackRefreshRate(CGDirectDisplayID displayID)
 //
 void _glfwPollMonitorsNS(void)
 {
+    fprintf(stderr, "-- _glfwPollMonitorsNS 1\n");
+
     uint32_t displayCount;
     CGGetOnlineDisplayList(0, NULL, &displayCount);
+    fprintf(stderr, "-- _glfwPollMonitorsNS 2 displayCount: %u\n", displayCount);
     CGDirectDisplayID* displays = calloc(displayCount, sizeof(CGDirectDisplayID));
+    fprintf(stderr, "-- _glfwPollMonitorsNS 3\n");
     CGGetOnlineDisplayList(displayCount, displays, &displayCount);
+    fprintf(stderr, "-- _glfwPollMonitorsNS 4\n");
+    fprintf(stderr, "-- _glfwPollMonitorsNS 4 _glfw.monitorCount %d\n", (int) _glfw.monitorCount);
 
     for (int i = 0;  i < _glfw.monitorCount;  i++)
         _glfw.monitors[i]->ns.screen = nil;
 
     _GLFWmonitor** disconnected = NULL;
     uint32_t disconnectedCount = _glfw.monitorCount;
+    fprintf(stderr, "-- _glfwPollMonitorsNS 5\n");
     if (disconnectedCount)
     {
         disconnected = calloc(_glfw.monitorCount, sizeof(_GLFWmonitor*));
@@ -316,14 +347,18 @@ void _glfwPollMonitorsNS(void)
                _glfw.monitors,
                _glfw.monitorCount * sizeof(_GLFWmonitor*));
     }
+    fprintf(stderr, "-- _glfwPollMonitorsNS 6 displayCount %u\n", displayCount);
 
     for (uint32_t i = 0;  i < displayCount;  i++)
     {
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop iter %u\n", i);
         if (CGDisplayIsAsleep(displays[i]))
             continue;
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 1\n");
 
         const uint32_t unitNumber = CGDisplayUnitNumber(displays[i]);
         NSScreen* screen = nil;
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 2\n");
 
         for (screen in [NSScreen screens])
         {
@@ -335,6 +370,7 @@ void _glfwPollMonitorsNS(void)
             if (CGDisplayUnitNumber([screenNumber unsignedIntValue]) == unitNumber)
                 break;
         }
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 3\n");
 
         // HACK: Compare unit numbers instead of display IDs to work around
         //       display replacement on machines with automatic graphics
@@ -349,38 +385,60 @@ void _glfwPollMonitorsNS(void)
                 break;
             }
         }
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 4\n");
 
         if (j < disconnectedCount)
             continue;
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 5\n");
 
         const CGSize size = CGDisplayScreenSize(displays[i]);
         char* name = getMonitorName(displays[i], screen);
         if (!name)
             continue;
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 6\n");
 
         _GLFWmonitor* monitor = _glfwAllocMonitor(name, size.width, size.height);
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 7\n");
         monitor->ns.displayID  = displays[i];
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 8\n");
         monitor->ns.unitNumber = unitNumber;
         monitor->ns.screen     = screen;
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 9\n");
 
         free(name);
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 10\n");
 
         CGDisplayModeRef mode = CGDisplayCopyDisplayMode(displays[i]);
-        if (CGDisplayModeGetRefreshRate(mode) == 0.0)
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 11\n");
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 11 mode is null? %d mode %p\n", mode == NULL, mode)
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 11 CGDisplayModeGetRefreshRate %f\n", CGDisplayModeGetRefreshRate(mode));
+        if (CGDisplayModeGetRefreshRate(mode) == 0.0) {
+            fprintf(stderr, "-- _glfwPollMonitorsNS loop step 11 if is true\n");
             monitor->ns.fallbackRefreshRate = getFallbackRefreshRate(displays[i]);
+        } else {
+            fprintf(stderr, "-- _glfwPollMonitorsNS loop step 11 if is false\n");
+        }
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 12\n");
         CGDisplayModeRelease(mode);
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 13\n");
 
         _glfwInputMonitor(monitor, GLFW_CONNECTED, _GLFW_INSERT_LAST);
+        fprintf(stderr, "-- _glfwPollMonitorsNS loop step 14\n");
     }
+    fprintf(stderr, "-- _glfwPollMonitorsNS 7\n");
+    fprintf(stderr, "-- _glfwPollMonitorsNS 7 disconnectedCount %u\n", disconnectedCount);
 
     for (uint32_t i = 0;  i < disconnectedCount;  i++)
     {
         if (disconnected[i])
             _glfwInputMonitor(disconnected[i], GLFW_DISCONNECTED, 0);
     }
+    fprintf(stderr, "-- _glfwPollMonitorsNS 8\n");
 
     free(disconnected);
+    fprintf(stderr, "-- _glfwPollMonitorsNS 9\n");
     free(displays);
+    fprintf(stderr, "-- _glfwPollMonitorsNS 10\n");
 }
 
 // Change the current video mode
diff --git a/src/init.c b/src/init.c
index aebbece4..19857e49 100644
--- a/src/init.c
+++ b/src/init.c
@@ -55,6 +55,9 @@ static _GLFWinitconfig _glfwInitHints =
     {
         GLFW_TRUE,  // macOS menu bar
         GLFW_TRUE   // macOS bundle chdir
+    },
+    {
+        GLFW_FALSE, // Win32 messages in fiber
     }
 };
 
@@ -274,6 +277,9 @@ GLFWAPI void glfwInitHint(int hint, int value)
         case GLFW_COCOA_MENUBAR:
             _glfwInitHints.ns.menubar = value;
             return;
+        case GLFW_WIN32_MESSAGES_IN_FIBER:
+            _glfwInitHints.win32.msgInFiber = value;
+            return;
     }
 
     _glfwInputError(GLFW_INVALID_ENUM,
diff --git a/src/internal.h b/src/internal.h
index ad619b4e..5fd27be0 100644
--- a/src/internal.h
+++ b/src/internal.h
@@ -244,6 +244,9 @@ struct _GLFWinitconfig
         GLFWbool  menubar;
         GLFWbool  chdir;
     } ns;
+    struct {
+        GLFWbool  msgInFiber;
+    } win32;
 };
 
 // Window configuration
diff --git a/src/wgl_context.c b/src/wgl_context.c
index 72ad11de..bfb41e00 100644
--- a/src/wgl_context.c
+++ b/src/wgl_context.c
@@ -453,6 +453,7 @@ GLFWbool _glfwInitWGL(void)
     pfd.iPixelType = PFD_TYPE_RGBA;
     pfd.cColorBits = 24;
 
+    // TODO: slow step, 40ms. Not much we can do, this is win32 and depends on the GL driver.
     if (!SetPixelFormat(dc, ChoosePixelFormat(dc, &pfd), &pfd))
     {
         _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
@@ -471,6 +472,7 @@ GLFWbool _glfwInitWGL(void)
     pdc = wglGetCurrentDC();
     prc = wglGetCurrentContext();
 
+    // TODO: slow step, 40ms.
     if (!wglMakeCurrent(dc, rc))
     {
         _glfwInputErrorWin32(GLFW_PLATFORM_ERROR,
diff --git a/src/win32_init.c b/src/win32_init.c
index 40eb795f..cb9a06c9 100644
--- a/src/win32_init.c
+++ b/src/win32_init.c
@@ -325,8 +325,6 @@ static void createKeyTables(void)
 //
 static GLFWbool createHelperWindow(void)
 {
-    MSG msg;
-
     _glfw.win32.helperWindowHandle =
         CreateWindowExW(WS_EX_OVERLAPPEDWINDOW,
                         _GLFW_WNDCLASSNAME,
@@ -362,13 +360,21 @@ static GLFWbool createHelperWindow(void)
                                         DEVICE_NOTIFY_WINDOW_HANDLE);
     }
 
-    while (PeekMessageW(&msg, _glfw.win32.helperWindowHandle, 0, 0, PM_REMOVE))
+    if (_glfw.hints.init.win32.msgInFiber)
     {
-        TranslateMessage(&msg);
-        DispatchMessageW(&msg);
+        SwitchToFiber(_glfw.win32.messageFiber);
+    }
+    else
+    {
+        MSG msg;
+        while (PeekMessageW(&msg, _glfw.win32.helperWindowHandle, 0, 0, PM_REMOVE))
+        {
+            TranslateMessage(&msg);
+            DispatchMessageW(&msg);
+        }
     }
 
-   return GLFW_TRUE;
+    return GLFW_TRUE;
 }
 
 
@@ -537,6 +543,44 @@ BOOL _glfwIsWindows10BuildOrGreaterWin32(WORD build)
     return RtlVerifyVersionInfo(&osvi, mask, cond) == 0;
 }
 
+void _glfwPollMessageLoopWin32(void)
+{
+    _GLFWwindow* window;
+    MSG msg;
+    while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE))
+    {
+        if (msg.message == WM_QUIT)
+        {
+            // NOTE: While GLFW does not itself post WM_QUIT, other processes
+            //       may post it to this one, for example Task Manager
+            // HACK: Treat WM_QUIT as a close on all windows
+
+            window = _glfw.windowListHead;
+            while (window)
+            {
+                _glfwInputWindowCloseRequest(window);
+                window = window->next;
+            }
+        }
+        else
+        {
+            TranslateMessage(&msg);
+            DispatchMessageW(&msg);
+        }
+    }
+}
+
+// Windows message dispatch fiber
+void CALLBACK messageFiberProc(LPVOID lpFiberParameter)
+{
+    (void)lpFiberParameter;
+
+    for (;;)
+    {
+        _glfwPollMessageLoopWin32();
+        SwitchToFiber(_glfw.win32.mainFiber);
+    }
+}
 
 //////////////////////////////////////////////////////////////////////////
 //////                       GLFW platform API                      //////
@@ -565,6 +609,17 @@ int _glfwPlatformInit(void)
     else if (IsWindowsVistaOrGreater())
         SetProcessDPIAware();
 
+    if (_glfw.hints.init.win32.msgInFiber)
+    {
+        _glfw.win32.mainFiber = ConvertThreadToFiber(NULL);
+        if (!_glfw.win32.mainFiber)
+            return GLFW_FALSE;
+
+        _glfw.win32.messageFiber = CreateFiber(0, &messageFiberProc, NULL);
+        if (!_glfw.win32.messageFiber)
+            return GLFW_FALSE;
+    }
+
     if (!_glfwRegisterWindowClassWin32())
         return GLFW_FALSE;
 
@@ -588,6 +643,12 @@ void _glfwPlatformTerminate(void)
 
     _glfwUnregisterWindowClassWin32();
 
+    if (_glfw.hints.init.win32.msgInFiber)
+    {
+        DeleteFiber(_glfw.win32.messageFiber);
+        ConvertFiberToThread();
+    }
+
     // Restore previous foreground lock timeout system setting
     SystemParametersInfoW(SPI_SETFOREGROUNDLOCKTIMEOUT, 0,
                           UIntToPtr(_glfw.win32.foregroundLockTimeout),
diff --git a/src/win32_platform.h b/src/win32_platform.h
index b964e135..a7aaef10 100644
--- a/src/win32_platform.h
+++ b/src/win32_platform.h
@@ -324,6 +324,11 @@ typedef struct _GLFWwindowWin32
     int                 lastCursorPosX, lastCursorPosY;
     // The last recevied high surrogate when decoding pairs of UTF-16 messages
     WCHAR               highSurrogate;
+
+    // If user pressed mouse button on window title bar
+    UINT                ncMouseButton;
+    LPARAM              ncMousePos;
+
 } _GLFWwindowWin32;
 
 // Win32-specific global data
@@ -345,6 +350,8 @@ typedef struct _GLFWlibraryWin32
     RAWINPUT*           rawInput;
     int                 rawInputSize;
     UINT                mouseTrailSize;
+    LPVOID              messageFiber;
+    LPVOID              mainFiber;
 
     struct {
         HINSTANCE                       instance;
@@ -450,3 +457,4 @@ void _glfwSetVideoModeWin32(_GLFWmonitor* monitor, const GLFWvidmode* desired);
 void _glfwRestoreVideoModeWin32(_GLFWmonitor* monitor);
 void _glfwGetMonitorContentScaleWin32(HMONITOR handle, float* xscale, float* yscale);
 
+void _glfwPollMessageLoopWin32(void);
diff --git a/src/win32_window.c b/src/win32_window.c
index 2fa4f2e1..f3d53c52 100644
--- a/src/win32_window.c
+++ b/src/win32_window.c
@@ -821,11 +821,46 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg,
             return 0;
         }
 
+        case WM_NCLBUTTONDOWN:
+        {
+            if (wParam == HTCAPTION)
+            {
+                window->win32.ncMouseButton = uMsg;
+                window->win32.ncMousePos = lParam;
+                return 0;
+            }
+            break;
+        }
+
+        case WM_NCMOUSEMOVE:
+        {
+            if (window->win32.ncMouseButton)
+            {
+                if (GET_X_LPARAM(window->win32.ncMousePos) != GET_X_LPARAM(lParam) ||
+                    GET_Y_LPARAM(window->win32.ncMousePos) != GET_Y_LPARAM(lParam))
+                {
+                    DefWindowProcW(hWnd, window->win32.ncMouseButton, HTCAPTION, window->win32.ncMousePos);
+                    window->win32.ncMouseButton = 0;
+                }
+            }
+            break;
+        }
+
         case WM_MOUSEMOVE:
         {
             const int x = GET_X_LPARAM(lParam);
             const int y = GET_Y_LPARAM(lParam);
 
+            if (window->win32.ncMouseButton)
+            {
+                if (GET_X_LPARAM(window->win32.ncMousePos) != x ||
+                    GET_Y_LPARAM(window->win32.ncMousePos) != y)
+                {
+                    DefWindowProcW(hWnd, window->win32.ncMouseButton, HTCAPTION, window->win32.ncMousePos);
+                    window->win32.ncMouseButton = 0;
+                }
+            }
+
             if (!window->win32.cursorTracked)
             {
                 TRACKMOUSEEVENT tme;
@@ -937,6 +972,9 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg,
         case WM_ENTERSIZEMOVE:
         case WM_ENTERMENULOOP:
         {
+            if (_glfw.hints.init.win32.msgInFiber)
+                SetTimer(hWnd, 1, 1, NULL);
+
             if (window->win32.frameAction)
                 break;
 
@@ -951,6 +989,9 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg,
         case WM_EXITSIZEMOVE:
         case WM_EXITMENULOOP:
         {
+            if (_glfw.hints.init.win32.msgInFiber)
+                KillTimer(hWnd, 1);
+
             if (window->win32.frameAction)
                 break;
 
@@ -962,6 +1003,13 @@ static LRESULT CALLBACK windowProc(HWND hWnd, UINT uMsg,
             break;
         }
 
+        case WM_TIMER:
+        {
+            if (_glfw.hints.init.win32.msgInFiber && wParam == 1)
+                SwitchToFiber(_glfw.win32.mainFiber);
+            break;
+        }
+
         case WM_SIZE:
         {
             const int width = LOWORD(lParam);
@@ -1397,6 +1445,7 @@ int _glfwPlatformCreateWindow(_GLFWwindow* window,
     {
         if (ctxconfig->source == GLFW_NATIVE_CONTEXT_API)
         {
+            // TODO: slow step, 90ms.
             if (!_glfwInitWGL())
                 return GLFW_FALSE;
             if (!_glfwCreateContextWGL(window, ctxconfig, fbconfig))
@@ -1923,31 +1972,13 @@ GLFWbool _glfwPlatformRawMouseMotionSupported(void)
 
 void _glfwPlatformPollEvents(void)
 {
-    MSG msg;
     HWND handle;
     _GLFWwindow* window;
 
-    while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE))
-    {
-        if (msg.message == WM_QUIT)
-        {
-            // NOTE: While GLFW does not itself post WM_QUIT, other processes
-            //       may post it to this one, for example Task Manager
-            // HACK: Treat WM_QUIT as a close on all windows
-
-            window = _glfw.windowListHead;
-            while (window)
-            {
-                _glfwInputWindowCloseRequest(window);
-                window = window->next;
-            }
-        }
-        else
-        {
-            TranslateMessage(&msg);
-            DispatchMessageW(&msg);
-        }
-    }
+    if (_glfw.hints.init.win32.msgInFiber)
+        SwitchToFiber(_glfw.win32.messageFiber);
+    else
+        _glfwPollMessageLoopWin32();
 
     // HACK: Release modifier keys that the system did not emit KEYUP for
     // NOTE: Shift keys on Windows tend to "stick" when both are pressed as
diff --git a/src/window.c b/src/window.c
index b87a2609..6aed705e 100644
--- a/src/window.c
+++ b/src/window.c
@@ -221,6 +221,7 @@ GLFWAPI GLFWwindow* glfwCreateWindow(int width, int height,
         return NULL;
     }
 
+    // TODO: slow step, 50ms.
     if (ctxconfig.client != GLFW_NO_API)
     {
         if (!_glfwRefreshContextAttribs(window, &ctxconfig))
